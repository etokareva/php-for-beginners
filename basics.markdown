# Базовый синтаксис

## Введение

Изучение любого языка программирования начинается с классической и самой простой программы “Hello, world”:


    <?php
    echo "Hello, world!";

Любой PHP-скрипт начинается с открывающего тэга `<?php`. Не надо писать другой код на одной строке с открывающим тэгом (из этого правила есть исключения, но о них позже). С помощью конструкции `echo` происходит отображение информации. 

Попробуем немного расширить первый пример:

    <?php
    $myName = 'Jack';
    echo 'Hello, world! My name is ' . $myName . ' I am the new superstar!';

`$myName` – это переменная. Их используют для осуществления доступа к данным. В ходе выполнения программы значение переменных можно изменять. Попробуйте, например, изменить значение в кавычка на свое имя.

Обратите внимание на текст после оператора `echo` в данном примере. `.` — это знак конкатенации, он отвечает за соединение нескольких строк в одну. Заодно с его помощью можно объединять со строкой и переменные.

PHP можно использовать не только для написания отдельных скриптов. Он спроектирован таким образом, что код можно вставлять прямо в html-код.

    <!DOCTYPE html>
    <html>
        <head>
            <meta charset="utf-8">
            <title>PHP Test</title>
        </head>
        <body>
            <?php echo '<p>Hello World</p>'; ?> 
        </body>
    </html>

Использование html-тэга `<meta charset="utf-8">` обеспечит корректное отображение русского текста в браузере. При этом важно проследить, чтобы ваш текстовый редактор сохранял файлы в кодировке utf-8.

В этом примере мы как раз видим исключения из правила «не писать другой код на одной строке с открывающим php тэгом». Если все, что мы хотим сделать, это вывести какую-то строку через PHP внутри html, то написание на одной строке — оптимальный вариант.

## Тэги

Как уже было показано выше, код на PHP окружается в специальные тэги. Рекомендуется использовать стандартные тэги:


    <?php 
    echo "code goes here";
    ?>

Стандартные тэги нельзя отключить в конфигурации, поэтому они гарантировано будут работать всегда.

Важно заметить, что закрывающий тэг необязательно и нежелательно ставить, если в файле содержится только PHP код.

В отличии от стандартных тэгов, короткие можно отключить в конфиге PHP (с помощью директивы `short_open_tag`). Поэтому их использования лучше избегать.


    <?
    ... code
    ?>


У коротких тэгов есть еще одна вариация, которая является сокращением для `echo`, совмещенного с тэгами PHP:


    <?=$variable ?>
    <?php echo $variable; ?>

Эти конструкции идентичны с точки зрения PHP.

## Переменные

Выше уже упоминалсь про переменные и для чего они нужны. Вот несколько правил, которым должны подчиняться переменные в PHP:

* переменные обозначаются значком `$`
* имя переменной содержит только латинские буквы, символ _ и цифры
* имя переменной НЕ может начинаться с цифры

Переменные очень желательно называть осмысленно, т.е. так, чтобы их название тем или иным образом отражало, что именно содержится в самой переменной.

Посмотрим несколько примеров задания переменных и их названия:


    <?php
    $typical_variable_name = 'Типичное название переменной с разделением через подчеркивание.';
    $camelCaseStyleVariableName = 'Немного другой стиль именования.';
    $_anotherOne = 42;
    $_anotherOne2Or3 = true;

В PHP переменная может быть одного из 8 типов:

* Скалярные (простые): `boolean`, `string`, `integer`, `float`.
* Составные: `array`, `object`.
* Специальные: `resource`, `null`.

Интерпретатор языка сам определяет, какой тип у переменной, специально задавать это не нужно. Более того, он будет сам переводить переменные из одного типа в другой в зависимости от данных или производимых операций, но об этом еще будет позже. Пока посмотрим, как задаются переменные скалярных типов:


    <?php
    // boolean отвечает за хранение true или false
    $booleanVariable = true;

    // в integer само собой хранятся целые числа
    $integerVariable = 42;

    // float позволяет хранить дробные значения
    $floatOne = 1.05;

    // string говорит сам за себя
    $stringOfCourse = 'текст сообщения';

    // сразу глянем и на array, позволяющий работать с наборами данных
    // тут приведен синтаксим массивов для PHP, начиная с версии 5.4
    $arrayOfValues = [
        'name' => 'Neo',
        'fullName' => 'Mr. Anderson',
        'friends' => [
            'Trinity',
            'Morpheus',
        ],
    ];

    // специальный тип null означает пустоту, т.е. незаданное значение
    // часто используется для того, чтобы подготовить переменную для будущего использования
    $forFutureUse = null;

Про resource и object мы еще поговорим отдельно.

## Комметарии к коду

В примере кода задания переменных комментарии уже присутствовали. Там был пример однострочных комментариев, т.е. действующих только на ту строку, в которой они присутствует. Ниже будут другие примеры того, как можно оформлять и использовать комментарии к коду:


    <?php
    // Комментарий в одну строчку

    /* Многострочные комментарии 
    оформляются
    таким образом */

    /**
    * API Documentation Example – так оформляются описания к методам и функциям
    *
    * @param string $bar
    */
    function foo($bar) { }

    $comments = true;  /* Чем больше комментариев, тем проще разобраться потом. 
    Но код надо стараться писать так, чтобы он был понятен и без комментариев. */

    /* В этом случае сначала следует комментарий, на следующей строчке действие */
    $action_first = 0;

    $action_first = 1;  // на одной строке действие идет первым

А вот пример распространненных ошибок при работе с комментариями:


    <?php
    /* this is 
    commented */ but this is not */


    // This is also a single line comment 
    // New line comment ?> Here new line comment dont work, and this will be printed


## Операторы

Операторами в PHP, как и многих других языках программирования, называются по сути элементарные действия, которые могут принимать одно или несколько значений или выражений и преобразовывать их к новому результату. Звучит сложнее, чем есть на самом деле. Операторами, например, называются сложение, умножение и другие подобные действия.

Операторы делят на следующие:

* унарные, т.е. принимающие только одно значение, например, `!` – логический оператор «не»
* бинарные соответственно принимающие два параметра, таких большинство: `+`, `*` и многие другие
* тернарный оператор только один и он является сокращением условного оператора: `? :`

### Арифметические операторы

Работают так же, как и в привычных математических выражениях.


    <?php
    echo 2 + 2; // 4
    echo 3 - 2; // 1
    echo 1 * 2; // 2
    echo 4 / 2; // 2
    echo -2; // -2
    echo 3 % 2; // 1 (Остаток от деления)

Стоит отметить, что оператор `/` будет возвращать значение типа `float`. Исключением будет ситуация, когда оба операнда (делимое и делитель) будут типа `integer`, при этом результат деления будет целым числом без дробной части, тогда тип результата будет `integer`.

При попытке деления на ноль будет выводиться ошибка: `PHP Warning: Division by zero`.

Операнды остатка от деления `%` конвертируются в `integer` за счет отбрасывания дробной части до выполнения операции. А результат деления по модулю будет того же знака, что и делимое, т.е. результат `$a % $b` будет того же знака, что и `$a`.

### Присвоение

Оператор присвоения обозначается `=`, примеры работы с ним уже были выше. Используют его для задания значений переменным. Т.е. операнду слева от оператора присваивается значение выражения справа.

Присвоение может комбинироваться с арифмитическими операторами или конкатенацией строк. Например:


    <?php
    $a = 3;
    $a += 5; // 8

    $a *= 7; // 56

Отдельно стоит рассмотреть присваивание по ссылке. В отличии от предыдущих примеров в этом случае в новой переменной будет содержаться не копия предыдущего значения, а именно ссылка на него. Это проще понять на примере:


    <?php
    $a = 3;
    $b = &$a; // $b — ссылка на $a

    print "$a\n"; // 3
    print "$b\n"; // 3

    $a = 4; // изменим $a

    print "$a\n"; // 4
    print "$b\n"; // 4 , так как $b — это ссылка на $a


### Операторы сравнения

Как понятно из названия следующий набор операторов позволяет сравнивать значения. Результатом работы оператора всегда будет значение типа `boolean`, т.е. либо `true`, либо `false`.


    <?php
    $a == $b; // равенство — TRUE если $a равно $b после приведения типов.
    $a === $b; // идентичность — TRUE если $a равно $b, и они обе одного типа.
    $a != $b; // не равны — TRUE если $a не равно $b после приведения типов
    $a !== $b; // не идентичны — TRUE если $a не равно $b, или они оба разных типов
    $a < $b;
    $a > $b;
    $a <= $b;
    $a >= $b;

При сравнение есть несколько нюансов, про которые полезно знать:

* при сравнении числа и строки (или, если сравнение содержит строку, содержимое которой представляет собой число), оба операнда будут приводиться к числу
* при сравнении с помощью `===` и `!==` приведение типов, конечно, происходить не будет

При сравнении переменных (или просто данных) разных типов будут работать следующие правила приведения типов:

* `null` и `string` — `null` будет конвертироваться в пустую строку `''`
* `bool` или `null` со всем остальным — будет конвертацию в `boolean`

Небольшое предупреждение. Из-за того, как работают переменные типа `float` изнутри, не следует сравнивать две числа с плавающей точкой на равенство, так как результат может быть неправильным.


### Оператор управления ошибками

В PHP есть один особенный оператор `@`, который называется оператором управления ошибками. Если добавить его перед выражением в скрипте, любые ошибки, которые это выражение может произвести будут проигнорированы и не выведены. Даже если из-за ошибки не работает совсем ничего, работа скрипта молча прекратится.

Важно, что оператор работает именно на выражениях. Выражением могут быть переменные, вызовы фукнций или `include`, константы и подобное. Нельзя применить оператор к объявлению класса или функции или к целой структуре типа `if` или циклу.

### Операторы инкремента/декремента

PHP унаследовал от языка программирования `C` многое, в том числе и операторы инкремента и декремента.

* `++$a` (преинкремент) — сначала увеличивает значение `$a` на единицу, затем возвращает значение `$a`
`$a++` (постинкремент) — сначала возвращает значение `$a`, затем увеличивает его на единицу
`--$a` (предекремент) — аналогичен преинкременту, но декремент
`$a--` (постдекремент) — аналогичен постинкременту, но декремент

Интересно, что операцию инкремента можно применить к латинским буквам (символам ASCII) `[a-z]` и `[A-Z]`. Декремент так работать не будет. 

    <?php
    $a = 'Z';
    $a++;
    echo $a; // выведет 'AA'

На другие строки операция действовать не будет. Аналогично инкремент и декремент не поменяют значения `boolean`. Декремент не подействует на `null`, но при его инкременте вы получите `1`.

### Логические операторы

Рассмотрим, как PHP работает с логическими операторами.

* `$a and $b` (And) — `TRUE` если оба значения `TRUE`.
* `$a or $b` (Or) — `TRUE` если одно из значений `TRUE`.
* `$a xor $b` (Xor) — `TRUE` если одно из значений `TRUE`, но не оба.
* `! $a` (Not) — `TRUE` если `$a` не `TRUE`.
* `$a && $b` (And) — `TRUE` если оба значения `TRUE`.
* `$a || $b` (Or) — `TRUE` если одно из значений `TRUE`.

`&&` и `||` имеют больший приоритет во время выполнения в более сложных выражениях, чем `and` и `or`, поэтому при написании кода преимущественно используют их.

### Строковые операторы

Для работы со строками существует всего два просты оператора. Первый из них — оператор конкатенации `.`, который мы уже видели выше в усложненном примере "Hello, world". Он возвращает объединение аргументов слева и справа от него.

Второй строковый оператор комбинированный: конкатенация с присвоением `.=`. С его помощью можно присоединить значение переменной справа к переменной слева.

    <?php
    $text = "What a strange word concatenation.";
    $text .= " But who the hell cares.";


### Приоритет операторов

Еще один важный момент — это приоритет выполнения операторов. Например, в выражении `1 + 5 * 3` ответ будет `16`, а не `18`, потому что приоритет у умножения выше, чем у сложения. Управлять приоритетом можно с помощью скобок. Тогда выражение `(1 + 5) * 3` равно 18.

Подробнее о приоритетах операторов можно посмотреть в [официальном мануале](http://ru.php.net/manual/ru/language.operators.precedence.php).


## If

Конструкция `if` — одна из наиболее часто используемых и важных практически в любом языке программирования. С помощью нее можно в зависимости от значения выражения в условии выполнять тот или иной фрагмент кода.

    <?php
    if ($a > $b) {
      echo "a больше b";
    }

Этот пример выведет текст, если значение `$a` больше `$b`.

Если в коде необходимо выполнить одно выражение, если условие верно, и другое во всех других ситуациях, то используется `else`:

    <?php
    if ($a > $b) {
      echo "a больше, чем b";
    } else {
      echo "a НЕ больше, чем b";
    }

Если же нам важно проверить несколько условий, то можно использовать еще одно расширение — `elseif`.

    <?php
    if ($a > $b) {
        echo "a больше, чем b";
    } elseif ($a == $b) {
        echo "a равен b";
    } else {
        echo "a меньше, чем b";
    }

Блоков `elseif` может быть несколько. При этом выполнится только один блок из всех перечисленных во всей конструкции `if/elseif`, условие которого будет равно `true`. Если ни одно из условий не равно `true`, то выполнится код из блока `else`.

Условие в скобках не обязательно должно быть сравнением. Можно использовать выражения и функции.

    <?php
    if( $homer_is_happy > 155){
        echo ‘Bart is sad’;
    }

    if (you_are_hungry()) {
        go_eat_something();
    }

    if ($homer_is_fat = eat_donuts()) {
        $homer = ‘fat ass!’;
    }

Условия могут быть вложенными:

    if($firstCondition == true) {
           if($secondCondition == true) {
                echo ‘Оба условия выполнены’;
           }
    }


### Тернарный оператор

Еще один вид условного оператора — тернарный оператор `?:`. Его работу проще понять на примере.

    <?php
    $action = (empty($_POST['action'])) ? 'default' : $_POST['action'];

    // предыдущее выражение аналогично следующему
    if (empty($_POST['action'])) {
        $action = 'default';
    } else {
        $action = $_POST['action'];
    }

Начиная с PHP 5.3 среднюю часть тернарного выражения можно опускать:

    <?php
    $value = $test ?: 'default';

Значение `$value` будет равно `$test`, если оно приводится к `TRUE`. И `default` во всех остальных случаях.

Пожалуйста, никогда не пишите код, используя вложенность тернарных операторов. Во-первых, читать такой код решительно невозможно. Во-вторых, PHP ведет себя не самым очевидным образом при использовании таких конструкций.

## Циклы

### while (цикл с предусловием)

Посмотрим на простой пример использования цикла `while`.

    <?php
    $i = 1;
    while ($i <= 10) {
        echo $i++;
    }

Этот фрагмент кода выведет числа от 1 до 10 слитно друг за другом.

Простыми словами структура `while` говорит PHP выполнять вложенные в фигурные скобки выражения повторно до тех пор, пока выражение в самом `while` является `TRUE`. Каждый раз, когда PHP выполняет выражения в цикле - это одна итерация. Условие в круглых скобках проверяется каждый раз перед началом цикла. Т.е. если это выражение равно `FALSE` с самого начала, то цикл не выполнится ни разу.


### do-while (цикл с постусловием)

Этот вид циклов очень похож на предыдущий, но с одним отличием. Условие в фигурных скобках проверяется после выполнения тела цикла (кода в фигурных скобках), т.е. в конце итерации. Это значит, что первая итерация всегда выполнится.

    <?php
    $i = 10;
    do {
        echo $i--;
    } while ($i > 0);

Этот пример выведет числа от 10 до 1 слитно друг за другом.

### for (цикл со счетчиком)

Этот цикл самый сложный среди других в PHP, но понять принцип его работы не трудно. Например, следующий фрагмент кода выведет в столбик значения от 1 до 5, а после этого сумму всех этих чисел.

    <?php
    $sum = 0;
    for ($i = 1; $i <= 5; $i++)
    {
        echo $i . ‘<br />’;
        $sum += $i;
    }
    echo $sum;

Рассмотрим подробнее нюансы работы `for` на примере символического цикла.

    <?php
    for (expr1; expr2; expr3) {
        statement
    }

Выражение `expr1` будет выполнено один раз до начала работы цикла. Как правило через него задают начальное значение счетчика.

В начале каждой итерации оценивается выражение `expr2`. Если оно принимает значение `TRUE`, то цикл продолжается, и вложенные операторы будут выполнены. Если оно принимает значение `FALSE`, выполнение цикла заканчивается.

И в конце каждой итерации будет выполняться выражение `expr3` через которое как правило задается шаг для счетчика.

На самом деле цикл `for` может и больше, чем описано выше. Например, любое из трех `expr` может отсутствовать или состоять из нескольких выражений. Но для начала с этим лучше быть аккуратным. Подробнее прочитать можно в [документации по `for`](http://php.net/manual/ru/control-structures.for.php).

### foreach

Это тоже цикл, но предназначенный специально для работы с массивами. В соответствующем разделе мы еще разберем его подробнее.

По сути `foreach` позволяет последовательно совершить набор операций с каждым отдельным элементом массива.

    <?php
    foreach ($people_in_this_room as $person) {
        echo “You are awesome, “ . $person . “!”;
    }

    foreach (array(1, 2, 3, 4) as &$value) {
        $value = $value * 2;
    }

http://php.net/manual/ru/control-structures.foreach.php

### break


### continue





## Функции


## Константы